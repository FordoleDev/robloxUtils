local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
--loadstring(game:HttpGet("https://raw.githubusercontent.com/FordoleDev/robloxUtils/refs/heads/main/trigger"))()

local camera = workspace.CurrentCamera
local uis = game:GetService("UserInputService")
local plrs = game:GetService("Players")
local rp = game:GetService("ReplicatedStorage")
local rs = game:GetService("RunService")
local lplr = plrs.LocalPlayer
local char
local hum
local hump
local hue = 0
local rcolor
local tp = false
local aimkey
local isMobile = uis.TouchEnabled and not uis.KeyboardEnabled
local mobaim = false
print(isMobile)

local fov = Drawing.new("Circle")
fov.Radius = 50
fov.Thickness = 1
fov.Transparency = 1
fov.Visible = true
fov.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
fov.Filled = false

_G.Chams = false
_G.ChamsColor = Color3.fromRGB(255, 255, 255)
_G.ChamsTrans = 0
_G.RainbowChams = false
_G.Rainbowvm = false
_G.VMM = {"SmoothPlastic"}
_G.GlovesColor = false
_G.GlovesC = Color3.fromRGB(255, 255, 255)
_G.RGloves = false
_G.GunColor = false
_G.GunC = Color3.fromRGB(255, 255, 255)
_G.RGun = false
_G.GunM = {"ForceField"}
_G.NightMode = false
_G.NightModeScale = 1
_G.CFOVT = false
_G.CFOV = 75
_G.FOV = 50
_G.AimPart = {"Head"}
_G.TeamCheck = false
_G.Bhop = false
_G.BhopSpeed = 30
local oldbright = 1
local aim = false
local client

local function getClient()
	if client then return client end

	pcall(function()
		local playerGui = player:FindFirstChild("PlayerGui")
		if playerGui then
			local clientScript = playerGui:FindFirstChild("Client")
			if clientScript and clientScript:IsA("LocalScript") then
				client = getsenv(clientScript)
				if client and client.speedupdate then
					originalSpeedUpdate = client.speedupdate
				end
			end
		end
	end)
end

getClient()

if isMobile then
	local mobileAimButton = Instance.new("TextButton")
	mobileAimButton.Name = "MobileAimButton"
	mobileAimButton.Size = UDim2.new(0, 100, 0, 100)
	mobileAimButton.Position = UDim2.new(1, -120, 1, -120)
	mobileAimButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
	mobileAimButton.BackgroundTransparency = 0.5
	mobileAimButton.Text = "AIM"
	mobileAimButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	mobileAimButton.TextSize = 14
	mobileAimButton.Visible = false
	mobileAimButton.Parent = plrs.LocalPlayer.PlayerGui
	mobileAimButton.MouseButton1Down:Connect(function()
		mobaim = true
	end)

	mobileAimButton.MouseButton1Up:Connect(function()
		mobaim = false
	end)

	mobileAimButton.TouchLongPress:Connect(function()
		mobaim = true
	end)

	mobileAimButton.TouchEnded:Connect(function()
		mobaim = false
	end)
end

--if _G.triggerbotLoaded then return end
_G.triggerbotLoaded = true

_G.triggerbot = {
	Settings = {
		isEnabled = false,
		clickDelay = 0.5,
		lastClickTime = 0
	},
	load = function()
		local Players = game:GetService("Players")
		local UserInputService = game:GetService("UserInputService")
		local StarterGui = game:GetService("StarterGui")
		local RunService = game:GetService("RunService")
		local LocalPlayer = Players.LocalPlayer
		local mouse = LocalPlayer:GetMouse()

		local function isHoveringPlayer()
			if not mouse.Target then return false end

			local character = mouse.Target:FindFirstAncestorOfClass("Model")
			if not character then return false end

			local player = Players:GetPlayerFromCharacter(character)
			if not player or player == LocalPlayer then return false end

			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid and humanoid.Health > 0 then
				return true
			end

			return false
		end

		local function simulateClick()
			local vim = game:GetService("VirtualInputManager")
			vim:SendMouseButtonEvent(0, 0, 0, true, game, 1)
			task.wait(0.05)
			vim:SendMouseButtonEvent(0, 0, 0, false, game, 1)
		end

		RunService.RenderStepped:Connect(function()
			if _G.triggerbot.Settings.isEnabled then
				if isHoveringPlayer() then
					local currentTime = tick()
					if currentTime - _G.triggerbot.Settings.lastClickTime >= _G.triggerbot.Settings.clickDelay then
						simulateClick()
						_G.triggerbot.Settings.lastClickTime = currentTime
					end
				end
			end
		end)
	end
}

_G.triggerbot.load()

local function NewQuad(thickness, color)
	local quad = Drawing.new("Quad")
	quad.Visible = false
	quad.PointA = Vector2.new(0,0)
	quad.PointB = Vector2.new(0,0)
	quad.PointC = Vector2.new(0,0)
	quad.PointD = Vector2.new(0,0)
	quad.Color = color
	quad.Filled = false
	quad.Thickness = thickness
	quad.Transparency = 1
	return quad
end

local function NewLine(thickness, color)
	local line = Drawing.new("Line")
	line.Visible = false
	line.From = Vector2.new(0, 0)
	line.To = Vector2.new(0, 0)
	line.Color = color 
	line.Thickness = thickness
	line.Transparency = 1
	return line
end

_G.ESP = {
	Enabled = false,
	Box = {
		Enabled = false,
		Thickness = 1,
		Color = Color3.fromRGB(255, 255, 255)
	},
	Tracer = {
		Enabled = false,
		Thickness = 1,
		Color = Color3.fromRGB(255, 255, 255),
		Origin = "Bottom",
		FollowMouse = false
	},
	HealthBar = {
		Enabled = false
	},
	TeamCheck = {
		Enabled = false,
		Green = Color3.fromRGB(0, 255, 0),
		Red = Color3.fromRGB(255, 0, 0)
	},
	TeamColor = false
}

local black = Color3.fromRGB(0, 0, 0)
local ESPInstances = {}

local function CreateESP(plr)
	if ESPInstances[plr] then return end

	local boxLib = {
		black = NewQuad(_G.ESP.Box.Thickness * 2, black),
		box = NewQuad(_G.ESP.Box.Thickness, _G.ESP.Box.Color)
	}

	local tracerLib = {
		blacktracer = NewLine(_G.ESP.Tracer.Thickness * 2, black),
		tracer = NewLine(_G.ESP.Tracer.Thickness, _G.ESP.Tracer.Color)
	}

	local healthLib = {
		healthbar = NewLine(3, black),
		greenhealth = NewLine(1.5, black)
	}
	
	local allDrawings = {}
	for _, drawing in pairs(boxLib) do table.insert(allDrawings, drawing) end
	for _, drawing in pairs(tracerLib) do table.insert(allDrawings, drawing) end
	for _, drawing in pairs(healthLib) do table.insert(allDrawings, drawing) end

	ESPInstances[plr] = {
		Box = boxLib,
		Tracer = tracerLib,
		Health = healthLib,
		AllDrawings = allDrawings,
		Player = plr
	}
end

local function UpdateESP()
	if not _G.ESP.Enabled then
		-- Скрываем все ESP если отключено
		for plr, data in pairs(ESPInstances) do
			for _, drawing in pairs(data.AllDrawings) do
				drawing.Visible = false
			end
		end
		return
	end

	for plr, data in pairs(ESPInstances) do
		local character = plr.Character
		local humanoid = character and character:FindFirstChild("Humanoid")
		local rootPart = character and character:FindFirstChild("HumanoidRootPart")
		local head = character and character:FindFirstChild("Head")

		if not character or not humanoid or not rootPart or not head or humanoid.Health <= 0 then
			for _, drawing in pairs(data.AllDrawings) do
				drawing.Visible = false
			end
			continue
		end

		local humPos, onScreen = camera:WorldToViewportPoint(rootPart.Position)
		if not onScreen then
			for _, drawing in pairs(data.AllDrawings) do
				drawing.Visible = false
			end
			continue
		end

		local headPos = camera:WorldToViewportPoint(head.Position)
		local distanceY = math.clamp((Vector2.new(headPos.X, headPos.Y) - Vector2.new(humPos.X, humPos.Y)).magnitude, 2, math.huge)

		if _G.ESP.Box.Enabled then
			local function SizeQuad(quad)
				quad.PointA = Vector2.new(humPos.X + distanceY, humPos.Y - distanceY * 2)
				quad.PointB = Vector2.new(humPos.X - distanceY, humPos.Y - distanceY * 2)
				quad.PointC = Vector2.new(humPos.X - distanceY, humPos.Y + distanceY * 2)
				quad.PointD = Vector2.new(humPos.X + distanceY, humPos.Y + distanceY * 2)
			end

			SizeQuad(data.Box.box)
			SizeQuad(data.Box.black)

			data.Box.box.Visible = true
			data.Box.black.Visible = true
			data.Box.box.Color = _G.ESP.Box.Color
		else
			data.Box.box.Visible = false
			data.Box.black.Visible = false
		end

		if _G.ESP.Tracer.Enabled then
			if _G.ESP.Tracer.Origin == "Middle" then
				data.Tracer.tracer.From = camera.ViewportSize * 0.5
				data.Tracer.blacktracer.From = camera.ViewportSize * 0.5
			elseif _G.ESP.Tracer.Origin == "Bottom" then
				data.Tracer.tracer.From = Vector2.new(camera.ViewportSize.X * 0.5, camera.ViewportSize.Y)
				data.Tracer.blacktracer.From = Vector2.new(camera.ViewportSize.X * 0.5, camera.ViewportSize.Y)
			end

			if _G.ESP.Tracer.FollowMouse then
				data.Tracer.tracer.From = Vector2.new(mouse.X, mouse.Y + 36)
				data.Tracer.blacktracer.From = Vector2.new(mouse.X, mouse.Y + 36)
			end

			data.Tracer.tracer.To = Vector2.new(humPos.X, humPos.Y + distanceY * 2)
			data.Tracer.blacktracer.To = Vector2.new(humPos.X, humPos.Y + distanceY * 2)

			data.Tracer.tracer.Visible = true
			data.Tracer.blacktracer.Visible = true
			data.Tracer.tracer.Color = _G.ESP.Tracer.Color
		else
			data.Tracer.tracer.Visible = false
			data.Tracer.blacktracer.Visible = false
		end

		if _G.ESP.HealthBar.Enabled then
			local d = (Vector2.new(humPos.X - distanceY, humPos.Y - distanceY * 2) - Vector2.new(humPos.X - distanceY, humPos.Y + distanceY * 2)).magnitude 
			local healthOffset = humanoid.Health / humanoid.MaxHealth * d

			data.Health.greenhealth.From = Vector2.new(humPos.X - distanceY - 4, humPos.Y + distanceY * 2)
			data.Health.greenhealth.To = Vector2.new(humPos.X - distanceY - 4, humPos.Y + distanceY * 2 - healthOffset)

			data.Health.healthbar.From = Vector2.new(humPos.X - distanceY - 4, humPos.Y + distanceY * 2)
			data.Health.healthbar.To = Vector2.new(humPos.X - distanceY - 4, humPos.Y - distanceY * 2)

			local green = Color3.fromRGB(0, 255, 0)
			local red = Color3.fromRGB(255, 0, 0)
			data.Health.greenhealth.Color = red:lerp(green, humanoid.Health / humanoid.MaxHealth)

			data.Health.healthbar.Visible = true
			data.Health.greenhealth.Visible = true
		else
			data.Health.healthbar.Visible = false
			data.Health.greenhealth.Visible = false
		end

		if _G.ESP.TeamCheck.Enabled then
			local color = (plr.Team == lplr.Team) and _G.ESP.TeamCheck.Green or _G.ESP.TeamCheck.Red
			if _G.ESP.Box.Enabled then data.Box.box.Color = color end
			if _G.ESP.Tracer.Enabled then data.Tracer.tracer.Color = color end
		elseif _G.ESP.TeamColor then
			local teamColor = plr.TeamColor.Color
			if _G.ESP.Box.Enabled then data.Box.box.Color = teamColor end
			if _G.ESP.Tracer.Enabled then data.Tracer.tracer.Color = teamColor end
		end
	end
end

local function InitializeESP()
	for _, player in pairs(game:GetService("Players"):GetPlayers()) do
		if player ~= lplr then
			CreateESP(player)
		end
	end

	game:GetService("Players").PlayerAdded:Connect(function(player)
		if player ~= lplr then
			CreateESP(player)
		end
	end)

	game:GetService("Players").PlayerRemoving:Connect(function(player)
		if ESPInstances[player] then
			for _, drawing in pairs(ESPInstances[player].AllDrawings) do
				drawing:Remove()
			end
			ESPInstances[player] = nil
		end
	end)
end

local function ToggleESP(state)
	_G.ESP.Enabled = state
	if state then
		InitializeESP()
	else
		for _, data in pairs(ESPInstances) do
			for _, drawing in pairs(data.AllDrawings) do
				drawing.Visible = false
			end
		end
	end
end

local Window = Rayfield:CreateWindow({
	Name = "Rayfield Example Window",
	Icon = 0,
	LoadingTitle = "Rayfield Interface Suite",
	LoadingSubtitle = "by Sirius",
	ShowText = "Rayfield",
	Theme = "Default",

	ToggleUIKeybind = "K",

	DisableRayfieldPrompts = false,
	DisableBuildWarnings = false
})

local VisualsTab = Window:CreateTab("Visuals", 'box')

local ESPToggle = VisualsTab:CreateToggle({
	Name = "ESP",
	CurrentValue = _G.ESP.Enabled,
	Flag = "ESPToggle",
	Callback = function(Value)
		ToggleESP(Value)
	end,
})

local BoxToggle = VisualsTab:CreateToggle({
	Name = "Box ESP",
	CurrentValue = _G.ESP.Box.Enabled,
	Flag = "BoxToggle",
	Callback = function(Value)
		_G.ESP.Box.Enabled = Value
	end,
})

local TracerToggle = VisualsTab:CreateToggle({
	Name = "Tracer ESP",
	CurrentValue = _G.ESP.Tracer.Enabled,
	Flag = "TracerToggle", 
	Callback = function(Value)
		_G.ESP.Tracer.Enabled = Value
	end,
})

local HealthToggle = VisualsTab:CreateToggle({
	Name = "Health Bar",
	CurrentValue = _G.ESP.HealthBar.Enabled,
	Flag = "HealthToggle",
	Callback = function(Value)
		_G.ESP.HealthBar.Enabled = Value
	end,
})

local chamsToggle = VisualsTab:CreateToggle({
	Name = "Toggle chams",
	CurrentValue = _G.Chams,
	Flag = "Toggle1",
	Callback = function(Value)
		_G.Chams = Value
	end,
})

local chamsColorP = VisualsTab:CreateColorPicker({
	Name = "Chams color",
	Color = _G.ChamsColor,
	Flag = "ColorPicker1",
	Callback = function(Value)
		_G.ChamsColor = Value
	end
})

local RchamsToggle = VisualsTab:CreateToggle({
	Name = "Rainbow chams",
	CurrentValue = _G.RainbowChams,
	Flag = "Toggle1",
	Callback = function(Value)
		_G.RainbowChams = Value
	end,
})

local chamsTransS = VisualsTab:CreateSlider({
	Name = "Chams transparency",
	Range = {0, 1},
	Increment = 0.1,
	Suffix = "",
	CurrentValue = _G.ChamsTrans,
	Flag = "Slider1",
	Callback = function(Value)
		_G.ChamsTrans = Value
	end,
})

local RvmToggle = VisualsTab:CreateToggle({
	Name = "Rainbow ViewModel",
	CurrentValue = _G.Rainbowvm,
	Flag = "Toggle1",
	Callback = function(Value)
		_G.Rainbowvm = Value
	end,
})

local gunColorToggle = VisualsTab:CreateToggle({
	Name = "Gun Color Toggle",
	CurrentValue = _G.GunColor,
	Flag = "Toggle1",
	Callback = function(Value)
		_G.GunColor = Value
	end,
})

local gunColor = VisualsTab:CreateColorPicker({
	Name = "Gun color",
	Color = _G.GunC,
	Flag = "ColorPicker1",
	Callback = function(Value)
		_G.GunC = Value
	end
})

local RgunToggle = VisualsTab:CreateToggle({
	Name = "Rainbow Gun",
	CurrentValue = _G.RGun,
	Flag = "Toggle1",
	Callback = function(Value)
		_G.RGun = Value
	end,
})

local GunMDropdown = VisualsTab:CreateDropdown({
	Name = "Gun Material",
	Options = {"ForceField","Neon", "SmoothPlastic", "Glass"},
	CurrentOption = _G.GunM,
	MultipleOptions = false,
	Flag = "Dropdown1",
	Callback = function(Options)
		_G.GunM = Options
	end,
})


local glovesColorToggle = VisualsTab:CreateToggle({
	Name = "Gloves Color Toggle",
	CurrentValue = _G.GlovesColor,
	Flag = "Toggle1",
	Callback = function(Value)
		_G.GlovesColor = Value
	end,
})

local glovesColor = VisualsTab:CreateColorPicker({
	Name = "Gloves color",
	Color = _G.GlovesC,
	Flag = "ColorPicker1",
	Callback = function(Value)
		_G.GlovesC = Value
	end
})

local RglovesToggle = VisualsTab:CreateToggle({
	Name = "Rainbow Gloves",
	CurrentValue = _G.RGloves,
	Flag = "Toggle1",
	Callback = function(Value)
		_G.RGloves = Value
	end,
})

local nightModeToggle = VisualsTab:CreateToggle({
	Name = "Night Mode",
	CurrentValue = _G.NightMode,
	Flag = "Toggle1",
	Callback = function(Value)
		_G.NightMode = Value
	end,
})

local NightModeSlider = VisualsTab:CreateSlider({
	Name = "Night Mode Scale",
	Range = {0, 2},
	Increment = 0.1,
	Suffix = "",
	CurrentValue = _G.NightModeScale,
	Flag = "Slider1",
	Callback = function(Value)
		_G.NightModeScale = Value
	end,
})

local CFOVToggle = VisualsTab:CreateToggle({
	Name = "Camera FOV Toggle",
	CurrentValue = _G.CFOVT,
	Flag = "Toggle1",
	Callback = function(Value)
		_G.CFOVT = Value
	end,
})

local CFOVSlider = VisualsTab:CreateSlider({
	Name = "Camera FOV",
	Range = {60, 120},
	Increment = 1,
	Suffix = "",
	CurrentValue = _G.CFOV,
	Flag = "Slider1",
	Callback = function(Value)
		_G.CFOV = Value
	end,
})


local AimTab = Window:CreateTab("Aimbot", 'crosshair')

local FOVSlider = AimTab:CreateSlider({
	Name = "Aim FOV",
	Range = {0, 360},
	Increment = 1,
	Suffix = "",
	CurrentValue = _G.FOV,
	Flag = "Slider1",
	Callback = function(Value)
		_G.FOV = Value
	end,
})

local AimpartDropdown = AimTab:CreateDropdown({
	Name = "Aim part",
	Options = {"Head","HumanoidRootPart"},
	CurrentOption = _G.AimPart,
	MultipleOptions = false,
	Flag = "Dropdown1",
	Callback = function(Options)
		_G.AimPart = Options
	end,
})

local AimBind = AimTab:CreateKeybind({
	Name = "Aim Bind",
	CurrentKeybind = "F",
	HoldToInteract = true,
	Flag = "AimKeyBind",
	Callback = function(Keybind)

	end,
})

local TriggerBind = AimTab:CreateKeybind({
	Name = "Trigger Bind",
	CurrentKeybind = "T",
	HoldToInteract = false,
	Flag = "TriggerKeyBind",
	Callback = function(Keybind)
		_G.triggerbot.Settings.isEnabled = not _G.triggerbot.Settings.isEnabled
		print("Triggerbot:", _G.triggerbot.Settings.isEnabled)
	end,
})

local TriggerToggle = AimTab:CreateToggle({
	Name = "Trigger Toggle(for mobile)",
	CurrentValue = _G.triggerbot.Settings.isEnabled,
	Flag = "Toggle1",
	Callback = function(Value)
		_G.triggerbot.Settings.isEnabled = Value
	end,
})

local TriggerLabel = AimTab:CreateLabel("Trigger status: "..tostring(_G.triggerbot.Settings.isEnabled), "crosshair", Color3.fromRGB(0, 0, 0), false)

local triggerSlider = AimTab:CreateSlider({
	Name = "Trigger Delay",
	Range = {0, 1000},
	Increment = 1,
	Suffix = "ms",
	CurrentValue = _G.triggerbot.Settings.clickDelay * 1000,
	Flag = "Slider1",
	Callback = function(Value)
		_G.triggerbot.Settings.clickDelay = Value / 1000
	end,
})

local teamCheckToggle = AimTab:CreateToggle({
	Name = "Toggle TeamCheck",
	CurrentValue = _G.TeamCheck,
	Flag = "Toggle1",
	Callback = function(Value)
		_G.TeamCheck = Value
	end,
})

local bhopToggle = AimTab:CreateToggle({
	Name = "Bunnyhop",
	CurrentValue = _G.Bhop,
	Flag = "Toggle1",
	Callback = function(Value)
		_G.Bhop = Value
	end,
})

local bhopSlider = AimTab:CreateSlider({
	Name = "Bunnyhop speed",
	Range = {20, 100},
	Increment = 1,
	Suffix = "",
	CurrentValue = _G.BhopSpeed,
	Flag = "Slider1",
	Callback = function(Value)
		_G.BhopSpeed = Value
	end,
})


local ModsTab = Window:CreateTab("GunMods", 'plus')

local InfAmmo = ModsTab:CreateButton({
	Name = "InfAmmo",
	Callback = function()
		for _, v in ipairs(rp.Weapons:GetChildren()) do
			if v:FindFirstChild("Ammo") then
				v.Ammo.Value = 999
				v.StoredAmmo.Value = 100000
			end
		end
	end,
})

local NoSpread = ModsTab:CreateButton({
	Name = "NoSpread",
	Callback = function()
		for _, v in ipairs(rp.Weapons:GetChildren()) do
			if v:FindFirstChild("Spread") then
				v.Spread.Value = 0
				v.StoredAmmo.Value = 100000
				for _, r in v.Spread:GetChildren() do
					r.Value = 0
				end
			end
		end
	end,
})

local RapidFire = ModsTab:CreateButton({
	Name = "RapidFire",
	Callback = function()
		for _, v in ipairs(rp.Weapons:GetChildren()) do
			if v:FindFirstChild("FireRate") then
				v.FireRate.Value = 0
			end
		end
	end,
})

local autoGuns = ModsTab:CreateButton({
	Name = "AutoGuns",
	Callback = function()
		for _, v in ipairs(rp.Weapons:GetChildren()) do
			if v:FindFirstChild("Auto") then
				v.Auto.Value = true
			end
		end
	end,
})

local WallbangLegit = ModsTab:CreateButton({
	Name = "Legit Wallbang",
	Callback = function()
		for _, v in ipairs(rp.Weapons:GetChildren()) do
			if v:FindFirstChild("FireRate") then
				v.Penetration.Value = 10000000
			end
		end
	end,
})

local Wallbang = ModsTab:CreateButton({
	Name = "Wallbang",
	Callback = function()
		getgenv().Wallbang = true

		local mt = getrawmetatable(game)
		local namecallold = mt.__namecall
		setreadonly(mt, false)
		mt.__namecall = newcclosure(function(self, ...)
			local Args = {...}
			NamecallMethod = getnamecallmethod()
			if getgenv().Wallbang and tostring(NamecallMethod) == "FindPartOnRayWithIgnoreList" then
				table.insert(Args[2], workspace.Map)
			end
			return namecallold(self, ...)
		end)
		loadstring(game:HttpGet("https://raw.githubusercontent.com/FordoleDev/robloxUtils/refs/heads/main/test2", true))()
		setreadonly(mt, true)
	end,
})

local function enemy(plr)
	if _G.TeamCheck == false then
		return true
	end
	if plr.Team and lplr.Team then
		return plr.Team ~= lplr.Team
	end

	return true
end

local function alive(plr)
	if not plr or not plr.Character then
		return false
	end

	local hum = plr.Character:FindFirstChild("Humanoid")
	if not hum then
		return false
	end

	return hum.Health > 0
end

local function rainbowColor()
	hue = (hue + 0.001) % 1
	return Color3.fromHSV(hue, 1, 1)
end


uis.InputBegan:Connect(function(input, proc)
	if input.KeyCode == Enum.KeyCode.V then
		tp = true
		camera.CameraType = Enum.CameraType.Scriptable
		uis.MouseBehavior = Enum.MouseBehavior.LockCenter
	end
	if input.KeyCode == Enum.KeyCode[aimkey] then
		aim = true
	end
end)

uis.InputEnded:Connect(function(input, proc)
	if input.KeyCode == Enum.KeyCode.V then
		tp = false
		camera.CameraType = Enum.CameraType.Custom
		uis.MouseBehavior = Enum.MouseBehavior.Default
	end
	if input.KeyCode == Enum.KeyCode[aimkey] then
		aim = false
	end
end)

rs.RenderStepped:Connect(function()
	TriggerLabel:Set("Trigger status: "..tostring(_G.triggerbot.Settings.isEnabled), "crosshair", Color3.fromRGB(0, 0, 0), false)
	aimkey = Rayfield.Flags["AimKeyBind"] or AimBind.CurrentKeybind
	UpdateESP()
	--_G.triggerbot.Settings.toggleKey = Rayfield.Flags["TriggerKeyBind"] or TriggerBind.CurrentKeybind
	--print(_G.triggerbot.Settings.isEnabled)
	lplr = plrs.LocalPlayer
	char = lplr.Character
	if char then
		hum = char:FindFirstChild("Humanoid")
		hump = char:FindFirstChild("HumanoidRootPart")
	end
	fov.Radius = _G.FOV
	fov.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
	rcolor = rainbowColor()
	if _G.CFOVT then
		workspace.CurrentCamera.FieldOfView = _G.CFOV
	end
	local space = uis:IsKeyDown(Enum.KeyCode.Space)
	if space then
		if _G.Bhop then
			hum.WalkSpeed = _G.BhopSpeed
			hum.JumpPower = 30
			if client and client.speedupdate then
				client.speedupdate = function() end
			end
			local state = hum:GetState()
			if state == Enum.HumanoidStateType.Running or state == Enum.HumanoidStateType.Landed then
				hum.Jump = true
			end
		end
	else
		if client and originalSpeedUpdate then
			client.speedupdate = originalSpeedUpdate
			pcall(function()
				client.speedupdate()
			end)
		end
		--hum.WalkSpeed = 16
		--hum.JumpPower = 22
	end
	if tp then
		local offset = char.HumanoidRootPart.CFrame.lookVector * -8 + Vector3.new(0, 3, 0)
		camera.CFrame = CFrame.new(char.HumanoidRootPart.Position + offset, char.HumanoidRootPart.Position)
	end
	for _, plr in plrs:GetPlayers() do
		if plr.Character and plr ~= lplr then
			local isEnemy = enemy(plr)
			local isAlive = alive(plr)
			for _, part in ipairs(plr.Character:GetChildren()) do
				if part:IsA("MeshPart") or part:IsA("Part") then
					if _G.Chams and isEnemy and isAlive then
						local chams = part:FindFirstChild("Chams")
						if not chams then
							local chams = Instance.new("BoxHandleAdornment", part)
							chams.Name = "Chams"
							chams.AlwaysOnTop = true
							chams.ZIndex = 4
							chams.Adornee = part
							chams.Size = part.Size * Vector3.new(1.1, 1.1, 1.1)
							chams.Color3 = _G.ChamsColor
							chams.Transparency = _G.ChamsTrans
							if part.Name == "Head" then
								chams.Size = Vector3.new(1, 1, 1)
							end
						else
							chams.Transparency = _G.ChamsTrans
							if _G.RainbowChams then
								chams.Color3 = rcolor
							else
								chams.Color3 = _G.ChamsColor
							end
						end
					else
						if part:FindFirstChild("Chams") then
							part.Chams:Destroy()
						end
					end
				end
			end
		end
	end
	if aim == true or (isMobile and mobaim) then
		local closestPlayer = nil
		local closestDist = math.huge

		local inputPos
		if isMobile then
			local touchInputs = uis:GetTouchInputs()
			if #touchInputs > 0 then
				inputPos = touchInputs[1].Position
			else
				return
			end
		else
			inputPos = uis:GetMouseLocation()
		end

		for _, plr in plrs:GetPlayers() do
			if plr.Character and plr ~= plrs.LocalPlayer then
				if enemy(plr) and alive(plr) and plr.Character:FindFirstChild(_G.AimPart[1]) then
					local aimpart = _G.AimPart[1]
					local targetPart = plr.Character:FindFirstChild(aimpart)
					local screenpoint = camera:WorldToViewportPoint(targetPart.Position)

					if screenpoint.Z > 0 then
						local screenpos = Vector2.new(screenpoint.X, screenpoint.Y)
						if hump then
							local distance = (targetPart.Position - hump.Position).Magnitude
							-- ИСПРАВЬ эту строку - используй inputPos вместо mpos:
							if (screenpos - inputPos).Magnitude <= _G.FOV and distance < closestDist then
								closestPlayer = plr
								closestDist = distance
							end
						end
					end
				end
			end
		end

		if closestPlayer then
			local aimpart = _G.AimPart[1]
			local targetPart = closestPlayer.Character:FindFirstChild(aimpart)
			if targetPart then
				camera.CFrame = CFrame.new(camera.CFrame.Position, targetPart.Position)
			end
		end
	end
	if workspace.CurrentCamera:FindFirstChild("Arms") then
		for _, part in ipairs(game:GetService("Workspace").CurrentCamera.Arms:GetChildren()) do
			if part:IsA("Model") then
				for _, arm in part:GetChildren() do
					if arm.Name == "Right Arm" or arm.Name == "Left Arm" then
						if _G.Rainbowvm then
							arm.Color = rcolor
						end
						if _G.GlovesColor then
							for _, glove in arm:GetChildren() do
								if glove.Name == "Glove" then
									glove.Mesh.TextureId = ""
									if _G.RGloves then
										glove.Color = rcolor
									else
										glove.Color = _G.GlovesC
									end
								end
							end
						end
					end
				end
			end
			if _G.GunColor then
				if part:IsA("MeshPart") then
					part.Material = Enum.Material.Neon
					if _G.RGun then
						part.Color = rcolor
					else
						part.Color = _G.GunC
					end
					part.Material = Enum.Material[_G.GunM[1]]
					part.TextureID = ""
					if part:FindFirstChild("SurfaceAppearance") then
						part:FindFirstChild("SurfaceAppearance"):Destroy()
					end
				end
			end
		end
	end
	if _G.NightMode then
		game:GetService("Lighting").Brightness = _G.NightModeScale
	end
end)
